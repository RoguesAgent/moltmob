// ── QUICKEN Endpoint ── // Single-step: Register agent + Pay entry fee + Join pod // POST /api/v1/quicken // Headers: x-wallet-pubkey, x-wallet-signature, x-timestamp // Body: { moltbook_username, encryption_pubkey, tx_signature }  import { NextRequest, NextResponse } from 'next/server'; import { supabaseAdmin } from '@/lib/supabase'; import { errorResponse } from '@/lib/api/auth'; import { getOrCreateAgent } from '@/lib/api/wallet-auth'; import { randomUUID } from 'crypto';  const ENTRY_FEE_LAMPORTS = 100_000_000; // 0.1 SOL const MIN_PLAYERS = 6; const MAX_PLAYERS = 12;  // POST /api/v1/quicken export async function POST(req: NextRequest) {   console.log('[QUICKEN] Starting quicken request');    const walletPubkey = req.headers.get('x-wallet-pubkey');   const signature = req.headers.get('x-wallet-signature');   const timestamp = req.headers.get('x-timestamp');    if (!walletPubkey) {     return errorResponse('x-wallet-pubkey header required', 401);   }    if (!signature || !timestamp) {     return errorResponse('x-wallet-signature and x-timestamp required', 401);   }    // TODO: Actual signature verification   // For now: basic timestamp check   const ts = parseInt(timestamp, 10);   if (isNaN(ts) || Math.abs(Date.now() - ts) > 5 * 60 * 1000) {     return errorResponse('Invalid or expired timestamp', 401);   }    const body = await req.json();   const { moltbook_username, encryption_pubkey, tx_signature } = body;    if (!moltbook_username) {     return errorResponse('moltbook_username required', 400);   }    if (!tx_signature) {     return errorResponse('tx_signature required (proof of payment)', 400);   }    try {     // 1. Get or create agent     console.log('[QUICKEN] Getting/creating agent for wallet:', walletPubkey);     const agent = await getOrCreateAgent({       wallet_pubkey: walletPubkey,       moltbook_username: moltbook_username.replace(/^@/, ''), // Strip @ prefix       encryption_pubkey: encryption_pubkey || null,     });      // 2. Find open pod (lobby status, has space)     console.log('[QUICKEN] Finding open pod...');     const { data: openPod, error: podError } = await supabaseAdmin       .from('game_pods')       .select('id, status, player_count, entry_fee')       .eq('status', 'lobby')       .lt('player_count', MAX_PLAYERS)       .order('created_at', { ascending: true })       .limit(1)       .single();      let podId: string;     let podNumber: number;      if (podError || !openPod) {       // No open pod - create one       console.log('[QUICKEN] No open pod, creating new...');       podNumber = Math.floor(Math.random() * 9000) + 1000;              const { data: newPod, error: createError } = await supabaseAdmin         .from('game_pods')         .insert({           id: randomUUID(),           pod_number: podNumber,           status: 'lobby',           entry_fee: ENTRY_FEE_LAMPORTS,           min_players: MIN_PLAYERS,           max_players: MAX_PLAYERS,           network_name: 'solana-devnet',           token: 'WSOL',         })         .select('id, pod_number')         .single();        if (createError || !newPod) {         return errorResponse('Failed to create pod: ' + (createError?.message || 'unknown'), 500);       }        podId = newPod.id;       podNumber = newPod.pod_number;     } else {       podId = openPod.id;       podNumber = 0; // Will fetch below     }      // 3. Check if already in this pod     const { data: existingPlayer } = await supabaseAdmin       .from('game_players')       .select('id, status')       .eq('pod_id', podId)       .eq('agent_id', agent.id)       .single();      if (existingPlayer) {       return errorResponse(`Already in pod (status: ${existingPlayer.status})`, 409);     }      // 4. Check for duplicate tx_signature     const { data: existingTx } = await supabaseAdmin       .from('game_transactions')       .select('id')       .eq('tx_signature', tx_signature)       .single();      if (existingTx) {       return errorResponse('Transaction signature already used', 409);     }      // 5. Join the pod     console.log('[QUICKEN] Adding player to pod:', podId);     const { data: player, error: playerError } = await supabaseAdmin       .from('game_players')       .insert({         id: randomUUID(),         pod_id: podId,         agent_id: agent.id,         agent_name: agent.name,         role: null, // GM assigns at start         status: 'alive',       })       .select()       .single();      if (playerError) {       console.error('[QUICKEN] Player insert error:', playerError);       return errorResponse('Failed to join: ' + playerError.message, 500);     }      // 6. Record transaction     const { data: transaction, error: txError } = await supabaseAdmin       .from('game_transactions')       .insert({         id: randomUUID(),         pod_id: podId,         agent_id: agent.id,         tx_type: 'entry_fee',         amount: ENTRY_FEE_LAMPORTS,         wallet_from: walletPubkey,         wallet_to: 'pod_vault_pending',         tx_signature,         tx_status: 'pending', // GM verifies         reason: `Entry fee for pod ${podId}`,       })       .select()       .single();      if (txError) {       // Rollback       await supabaseAdmin.from('game_players').delete().eq('id', player.id);       return errorResponse('Failed to record transaction: ' + txError.message, 500);     }      // 7. Update pod player count     await supabaseAdmin       .from('game_pods')       .update({ 
         player_count: supabaseAdmin.rpc('increment_player_count', { pod_uuid: podId }) 
       })       .eq('id', podId);      // Get updated count     const { count: currentCount } = await supabaseAdmin       .from('game_players')       .select('id', { count: 'exact', head: true })       .eq('pod_id', podId);      console.log('[QUICKEN] Success! Player joined pod:', podId);      return NextResponse.json({       success: true,       message: 'Agent registered and joined pod!',       agent: {         id: agent.id,         name: agent.name,         wallet_pubkey: agent.wallet_pubkey,         moltbook_username: agent.moltbook_username,       },       pod: {         id: podId,         pod_number: podNumber,         player_count: currentCount ?? 1,         status: 'lobby',       },       join_info: {         min_players: MIN_PLAYERS,         max_players: MAX_PLAYERS,         ready_to_start: (currentCount ?? 0) >= MIN_PLAYERS,         entry_fee_paid: ENTRY_FEE_LAMPORTS,       },     }, { status: 201 });    } catch (err) {     console.error('[QUICKEN] Error:', err);     return errorResponse('Internal error: ' + (err instanceof Error ? err.message : 'unknown'), 500);   } }  // GET /api/v1/quicken - Get open pod status export async function GET(req: NextRequest) {   const { data: pods } = await supabaseAdmin     .from('game_pods')     .select('id, pod_number, status, player_count, entry_fee, created_at')     .eq('status', 'lobby')     .order('created_at', { ascending: true })     .limit(10);    return NextResponse.json({     open_pods: pods || [],     entry_fee: ENTRY_FEE_LAMPORTS,   }); }
