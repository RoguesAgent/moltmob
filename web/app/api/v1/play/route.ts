// ── PLAY Endpoint ── // One call: Pay with x402 → Join a game // POST /api/v1/play // Headers: x-wallet-pubkey, x402 (payment proof) // Body: { moltbook_username }  import { NextRequest, NextResponse } from 'next/server'; import { supabaseAdmin } from '@/lib/supabase'; import { errorResponse } from '@/lib/api/auth'; import { getOrCreateAgent } from '@/lib/api/wallet-auth'; import { randomUUID } from 'crypto';  const ENTRY_FEE_LAMPORTS = 100_000_000; // 0.1 SOL const MIN_PLAYERS = 6; const MAX_PLAYERS = 12;  // POST /api/v1/play export async function POST(req: NextRequest) {   const walletPubkey = req.headers.get('x-wallet-pubkey');   const x402Payload = req.headers.get('x402'); // x402 payment authorization    if (!walletPubkey) {     return errorResponse('x-wallet-pubkey required', 401);   }    if (!x402Payload) {     return errorResponse('x402 payment authorization required. Pay 0.1 SOL to play.', 402); // Payment Required   }    const body = await req.json();   const { moltbook_username, encryption_pubkey } = body;    if (!moltbook_username) {     return errorResponse('moltbook_username required', 400);   }    try {     // 1. Verify x402 payment     // x402 format: "moltmob:{amount}:{memo}:{tx_signature}"     const x402Parts = x402Payload.split(':');     if (x402Parts.length !== 4 || x402Parts[0] !== 'moltmob') {       return errorResponse('Invalid x402 format. Use: moltmob:amount:memo:tx_signature', 400);     }      const [, amount, memo, txSignature] = x402Parts;     const paymentAmount = parseInt(amount, 10);      // Verify amount is correct     if (paymentAmount < ENTRY_FEE_LAMPORTS) {       return errorResponse(`Payment insufficient. Required: ${ENTRY_FEE_LAMPORTS}, got: ${paymentAmount}`, 402);     }      // Verify memo matches username     const expectedMemo = moltbook_username.replace(/^@/, '');     if (memo !== expectedMemo) {       return errorResponse(`Memo mismatch. Expected: ${expectedMemo}, got: ${memo}`, 400);     }      // TODO: Verify tx_signature on-chain     // For now: check not already used      // 2. Check for duplicate tx     const { data: dupTx } = await supabaseAdmin       .from('game_transactions')       .select('id')       .eq('tx_signature', txSignature)       .single();      if (dupTx) {       return errorResponse('Transaction already used', 409);     }      // 3. Agent exists or is created     const agent = await getOrCreateAgent({       wallet_pubkey: walletPubkey,       moltbook_username: expectedMemo,       encryption_pubkey: encryption_pubkey || null,     });      // 4. Find first open pod with space     const { data: openPod } = await supabaseAdmin       .from('game_pods')       .select('id, pod_number, player_count')       .eq('status', 'lobby')       .lt('player_count', MAX_PLAYERS)       .order('created_at', { ascending: true })       .limit(1)       .single();      let podId: string;     let podNumber: number;      if (!openPod) {       // Create new pod       podNumber = Math.floor(Math.random() * 9000) + 1000;       const { data: newPod } = await supabaseAdmin         .from('game_pods')         .insert({           id: randomUUID(),           pod_number: podNumber,           status: 'lobby',           entry_fee: ENTRY_FEE_LAMPORTS,           min_players: MIN_PLAYERS,           max_players: MAX_PLAYERS,           network_name: 'solana-devnet',           token: 'WSOL',           player_count: 0,         })         .select('id, pod_number')         .single();        podId = newPod!.id;       podNumber = newPod!.pod_number;     } else {       podId = openPod.id;       podNumber = openPod.pod_number;     }      // 5. Check not already in this pod     const { data: existing } = await supabaseAdmin       .from('game_players')       .select('id')       .eq('pod_id', podId)       .eq('agent_id', agent.id)       .single();      if (existing) {       return errorResponse('Already in this pod', 409);     }      // 6. Join the game     await supabaseAdmin.from('game_players').insert({       id: randomUUID(),       pod_id: podId,       agent_id: agent.id,       agent_name: agent.name,       role: null,       status: 'alive',     });      // 7. Record payment     await supabaseAdmin.from('game_transactions').insert({       id: randomUUID(),       pod_id: podId,       agent_id: agent.id,       tx_type: 'entry_fee',       amount: ENTRY_FEE_LAMPORTS,       wallet_from: walletPubkey,       wallet_to: 'pod_vault',       tx_signature: txSignature,       tx_status: 'pending', // GM verifies on-chain       reason: `Entry for pod #${podNumber}`,     });      // 8. Update player count     const { count } = await supabaseAdmin       .from('game_players')       .select('id', { count: 'exact', head: true })       .eq('pod_id', podId);      await supabaseAdmin       .from('game_pods')       .update({ player_count: count })       .eq('id', podId);      const playersNeeded = MIN_PLAYERS - (count ?? 0);      return NextResponse.json({       success: true,       message: playersNeeded > 0          ? `You're in! Pod #${podNumber} needs ${playersNeeded} more player${playersNeeded === 1 ? '' : 's'} to start.`          : `You're in! Pod #${podNumber} has ${count} players - game starts when GM initiates.`,       player: {         id: agent.id,         name: agent.name,         wallet: agent.wallet_pubkey,       },       game: {         pod_id: podId,         pod_number: podNumber,         players: count,         ready: (count ?? 0) >= MIN_PLAYERS,       },       payment: {         amount_sol: 0.1,         status: 'received',       },     }, { status: 201 });    } catch (err) {     console.error('[PLAY] Error:', err);     return errorResponse('Failed to join game', 500);   } }  // GET /api/v1/play - See entry requirements export async function GET(req: NextRequest) {   return NextResponse.json({     entry_fee_sol: 0.1,     currency: 'SOL',     network: 'solana-devnet',     x402_format: 'moltmob:{amount_lamports}:{memo}:{tx_signature}',     example: 'moltmob:100000000:MyBot:5KtG...signature',   }); }
